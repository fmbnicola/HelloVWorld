using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Block;

public class ConnectorCable : MonoBehaviour
{
    [SerializeField]
    private GameObject ConnectorNode;

    public Transform AnchorPoint;

    public Plug Plug;

    public LineRenderer Renderer;

    public List<ConnectorNode> Nodes;

    private readonly float Range = 1;

    private GameObject NodeParent;

    private ConnectorNode Head;
    private ConnectorNode Tail;


    // Start is called before the first frame update
    void Start()
    {
        this.Renderer = this.GetComponent<LineRenderer>();

        this.Nodes = new List<ConnectorNode>();

        this.NodeParent = new GameObject("Generated By Connector Cable");
        this.NodeParent.transform.position = Vector3.zero;

        this.Head = this.AddNode(this.AnchorPoint.position);
        this.Tail = this.AddNode(this.Plug.transform.position, this.Head);
    }


    // Update is called once per frame
    void LateUpdate()
    {
        this.Head.transform.position = this.AnchorPoint.position;
        this.Tail.transform.position = this.Plug.transform.position;

        if (this.Plug.State != Plug.States.OnAnchor)
        {
            #region Head
            var tooClose = this.CheckHeadProximity();

            // Contract Cable
            if (tooClose != null)
            {
                this.Snip(this.Head, tooClose);
            }

            // Extend Cable
            if (this.NodeDistance(this.Head, this.Head.Next) > this.Range)
            {
                this.ExtendHead();
            }
            #endregion

            #region Tail
            tooClose = this.CheckTailProximity();

            // Contract Cable
            if (tooClose != null)
            {
                this.Snip(tooClose, this.Tail);
            }
            

            // Extend Cable
            if (this.NodeDistance(this.Tail, this.Tail.Prev) > this.Range)
            {
                this.ExtendTail();
            }
            #endregion
        }

        this.Renderer.positionCount = this.Nodes.Count;
        this.Renderer.SetPositions(this.GetPositions());
    }


    public void OnDestroy()
    {
        Destroy(this.NodeParent);
    }



    #region Nodes
    private ConnectorNode CreateNode(Vector3 position)
    {
        var node = Instantiate(this.ConnectorNode);

        node.transform.position = position;

        node.transform.parent = this.NodeParent.transform;

        return node.GetComponent<ConnectorNode>();
    }

    private ConnectorNode AddNode(Vector3 position, ConnectorNode prev = null)
    {
        var node = this.CreateNode(position);

        if(prev != null) this.ConnectNodes(prev, node);

        node.Initialize(this, this.Nodes.Count);

        this.Nodes.Add(node);

        return node;
    }

    private void InsertNode(int index, ConnectorNode node)
    {
        var count = this.Nodes.Count;

        if (index >= count || node == null) return;

        this.Nodes.Insert(index, node);

        if (index - 1 >=     0) this.ConnectNodes(this.Nodes[index - 1], node);
        if (index + 1 <  count) this.ConnectNodes(node, this.Nodes[index + 1]);

        for(var i = index; i < this.Nodes.Count; i++)
        {
            this.Nodes[i].Index = i;
        }
    }

    private void RemoveNode(int index)
    {
        if (index <= 0 || this.Nodes.Count <= index) return;

        var node = this.Nodes[index];
        this.Nodes.RemoveAt(index);

        var prev = node.Prev;
        var next = node.Next;

        if(prev != null && next != null)
        {
            this.ConnectNodes(prev, next);
        }

        if (this.Tail == node) this.Tail = prev;

        for(var i = index; i < this.Nodes.Count; i++)
        {
            this.Nodes[i].Index = i;
        }

        Destroy(node.gameObject);
    }

    private void ConnectNodes(ConnectorNode first, ConnectorNode second)
    {
        first.Next  = second;
        second.Prev = first;
    }


    private float NodeDistance(ConnectorNode first, ConnectorNode second)
    {
        return (first.transform.position - second.transform.position).magnitude;
    }

    private ConnectorNode CheckHeadProximity()
    {
        foreach(var node in this.Nodes)
        {
            if (node == this.Head || node == this.Tail) continue;
            if (node == this.Head.Next) continue;

            if(this.NodeDistance(this.Head, node) < this.Range)
            {
                return node;
            }
        }

        return null;
    }

    private ConnectorNode CheckTailProximity()
    {
        foreach (var node in this.Nodes)
        {
            if (node == this.Head || node == this.Tail) continue;
            if (node == this.Tail.Prev) continue;

            if (this.NodeDistance(this.Tail, node) < this.Range)
            {
                return node;
            }
        }

        return null;
    }
    #endregion


    #region Extend
    private void ExtendHead()
    {
        var node = this.CreateNode(this.AnchorPoint.position);

        this.InsertNode(0, node);

        this.Head = node;
    }

    private void ExtendTail()
    {
        var node = this.AddNode(this.Plug.transform.position, this.Tail);

        this.Tail = node;
    }
    #endregion


    public void Snip(ConnectorNode from, ConnectorNode to)
    {
        if(from.Index > to.Index)
        {
            var temp = from;
            from = to;
            to = temp;
        }

        while(from.Next != to)
        {
            this.RemoveNode(from.Index + 1);
        }
    }


    public void Clear()
    {
        this.Nodes.Clear();

        Destroy(this.NodeParent);

        this.NodeParent = new GameObject("Generated By Connector Cable");
        this.NodeParent.transform.position = Vector3.zero;

        this.Head = this.AddNode(this.AnchorPoint.position);
        this.Tail = this.AddNode(this.Plug.transform.position, this.Head);
    }


    public Vector3[] GetPositions()
    {
        var array = new Vector3[this.Nodes.Count];

        var i = 0;

        foreach(var node in this.Nodes)
        {
            array[i++] = node.transform.position;
        }

        return array;
    }
}
